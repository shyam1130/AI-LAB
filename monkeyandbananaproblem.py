# -*- coding: utf-8 -*-
"""monkeyandbananaproblem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1en9QYyi2yyzATPl3uIPLIZc6VpiF3jH8
"""

from collections import deque

# Define successor function
def successor(state):
    monkey_pos, box_pos, has_bananas = state
    successors = []


    if monkey_pos != box_pos:
        successors.append((box_pos, box_pos, has_bananas))


    if monkey_pos == box_pos and not has_bananas:
        successors.append((monkey_pos, 'under_bananas', has_bananas))


    if monkey_pos == box_pos and not has_bananas:
        successors.append((monkey_pos, box_pos, has_bananas))


    if monkey_pos == 'under_bananas' and not has_bananas:
        successors.append((monkey_pos, box_pos, True))

    return successors


def bfs(initial_state, goal_state):
    queue = deque([(initial_state, [])])
    visited = set()

    while queue:
        state, path = queue.popleft()

        # Trace the current path
        current_path = path + [state]
        print(f"Current State: {state}, Path: {current_path}")

        if state == goal_state:
            return True, current_path

        visited.add(state)

        for succ in successor(state):
            if succ not in visited:
                queue.append((succ, current_path))

    return False, []

# Define the initial and final states
initial_state = ('monkey', 'box', False)
goal_state = ('monkey', 'box', True)


bfs_result, path_taken = bfs(initial_state, goal_state)

print("BFS Result:", bfs_result)
print("Path Taken:", path_taken)